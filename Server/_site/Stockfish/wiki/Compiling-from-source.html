<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title> | Chess </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content=" | Chess ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Moosdorf/Chess-Website-FULLSTACK/blob/main/Server/Stockfish/wiki/Compiling-from-source.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="Chess">
            Chess
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<h2 id="general">General</h2>
<p><code>make target [ARCH=arch] [COMP=compiler] [COMPCXX=cxx]</code></p>
<h3 id="targets">Targets</h3>
<pre><code>help                    &gt; Display architecture details
profile-build           &gt; standard build with profile-guided optimization
build                   &gt; skip profile-guided optimization
net                     &gt; Download the default nnue nets
strip                   &gt; Strip executable
install                 &gt; Install executable
clean                   &gt; Clean up
</code></pre>
<h3 id="archs">Archs</h3>
<pre><code>native                  &gt; select the best architecture for the host processor (default)
x86-64-vnni512          &gt; x86 64-bit with vnni 512bit support
x86-64-vnni256          &gt; x86 64-bit with vnni 512bit support, limit operands to 256bit wide
x86-64-avx512           &gt; x86 64-bit with avx512 support
x86-64-avxvnni          &gt; x86 64-bit with vnni 256bit support
x86-64-bmi2             &gt; x86 64-bit with bmi2 support
x86-64-avx2             &gt; x86 64-bit with avx2 support
x86-64-sse41-popcnt     &gt; x86 64-bit with sse41 and popcnt support
x86-64-modern           &gt; deprecated, currently x86-64-sse41-popcnt
x86-64-ssse3            &gt; x86 64-bit with ssse3 support
x86-64-sse3-popcnt      &gt; x86 64-bit with sse3 compile and popcnt support
x86-64                  &gt; x86 64-bit generic (with sse2 support)
x86-32-sse41-popcnt     &gt; x86 32-bit with sse41 and popcnt support
x86-32-sse2             &gt; x86 32-bit with sse2 support
x86-32                  &gt; x86 32-bit generic (with mmx compile support)
ppc-64                  &gt; PPC 64-bit
ppc-64-altivec          &gt; PPC 64-bit with altivec support
ppc-64-vsx              &gt; PPC 64-bit with vsx support
ppc-32                  &gt; PPC 32-bit
armv7                   &gt; ARMv7 32-bit
armv7-neon              &gt; ARMv7 32-bit with popcnt and neon
armv8                   &gt; ARMv8 64-bit with popcnt and neon
armv8-dotprod           &gt; ARMv8 64-bit with popcnt, neon and dot product support
e2k                     &gt; Elbrus 2000
apple-silicon           &gt; Apple silicon ARM64
general-64              &gt; unspecified 64-bit
general-32              &gt; unspecified 32-bit
riscv64                 &gt; RISC-V 64-bit
loongarch64             &gt; LoongArch 64-bit
loongarch64-lsx         &gt; LoongArch 64-bit with SIMD eXtension
loongarch64-lasx        &gt; LoongArch 64-bit with Advanced SIMD eXtension
</code></pre>
<h3 id="compilers">Compilers</h3>
<pre><code>gcc                     &gt; GNU compiler (default)
mingw                   &gt; GNU compiler with MinGW under Windows
clang                   &gt; LLVM Clang compiler
icx                     &gt; Intel oneAPI DPC++/C++ Compiler
ndk                     &gt; Google NDK to cross-compile for Android
</code></pre>
<h3 id="simple-examples">Simple examples</h3>
<p>If you don't know what to do, you likely want to run:</p>
<p>Fast compile for most common modern CPUs</p>
<pre><code class="lang-bash">make -j build
</code></pre>
<p>Slow compile for 64-bit systems</p>
<pre><code class="lang-bash">make -j build ARCH=x86-64
</code></pre>
<p>Slow compile for 32-bit systems</p>
<pre><code class="lang-bash">make -j build ARCH=x86-32
</code></pre>
<h3 id="advanced-examples">Advanced examples</h3>
<p>For experienced users looking for performance:</p>
<pre><code class="lang-bash"># Providing no ARCH so it will try to find the best ARCH for you
make -j profile-build
</code></pre>
<pre><code class="lang-bash">make -j profile-build ARCH=x86-64-bmi2
</code></pre>
<pre><code class="lang-bash">make -j profile-build ARCH=x86-64-bmi2 COMP=gcc COMPCXX=g++-9.0
</code></pre>
<pre><code class="lang-bash">make -j build ARCH=x86-64-ssse3 COMP=clang
</code></pre>
<p><em>See also: <a href="#lower-compilation-time">How to lower compilation time</a> and <a href="#optimize-for-your-cpu">How to optimize for your CPU</a>.</em></p>
<hr>
<h2 id="linux">Linux</h2>
<p>On Unix-like systems, it should be easy to compile Stockfish directly from the source code with the included Makefile in the folder <code>src</code>.</p>
<p>In general it is recommended to run <code>make help</code> to see a list of make targets with corresponding descriptions.</p>
<pre><code class="lang-bash">cd src
make help
make -j profile-build ARCH=x86-64-avx2
</code></pre>
<hr>
<h2 id="windows">Windows</h2>
<h3 id="about-msys2--mingw-w64">About MSYS2 &amp; MinGW-w64</h3>
<p>MSYS2 is a software distribution and building platform for Windows. It provides a Unix-like environment, a command line interface, and a software repository, making it easy to install software on Windows or build software on Windows with either the GCC compiler or the Clang/LLVM compiler and using the Microsoft Visual C++ Runtime (mvscrt, shipped with all Windows versions) or the newer Microsoft Universal C Runtime (ucrt, shipped by default starting with Windows 10).</p>
<p>MSYS2 consists of several subsystems, <code>msys2</code>, <code>mingw32</code>, and <code>mingw64</code>:</p>
<ul>
<li>The <code>mingw32</code> and <code>mingw64</code> subsystems are native Windows applications that use either the mvscrt or the ucrt.</li>
<li>The <code>msys2</code> subsystem provides an emulated mostly-POSIX-compliant environment based on Cygwin.</li>
</ul>
<p>Each subsystem has an associated &quot;terminal/shell&quot;, which is essentially a set of environment variables that allows the subsystems to co-operate properly:</p>
<ul>
<li><code>MSYS2 MinGW x64</code>, to build Windows-native 64-bit applications with GCC compiler using mvscrt.</li>
<li><code>MSYS2 MinGW x86</code>, to build Windows-native 32-bit applications using GCC compiler using mvscrt.</li>
<li><code>MSYS2 MSYS</code>, to build POSIX applications using the Cygwin compatibility layer.</li>
<li><code>MSYS2 MinGW UCRT x64</code>, to build Windows-native 64-bit applications with GCC compiler using ucrt.</li>
<li><code>MSYS2 MinGW Clang x64</code>, to build Windows-native 64-bit applications with Clang/LLVM compiler using ucrt.</li>
</ul>
<p>Refer to the <a href="https://www.msys2.org/">MSYS2 homepage</a> for more detailed information on the MSYS2 subsystems and terminals/shells.</p>
<h3 id="installing-msys2">Installing MSYS2</h3>
<h3 id="install-msys2-with-winget">Install MSYS2 with WinGet</h3>
<p><a href="https://learn.microsoft.com/en-us/windows/package-manager/winget/">WinGet</a> is the Microsoft command line tool enabling users to discover, install, upgrade, remove and configure applications on Windows 10, Windows 11, and Windows Server 2025 computers. This tool is the client interface to the Windows Package Manager service.</p>
<ol>
<li>Open a powershell and run:</li>
</ol>
<pre><code class="lang-cmd">winget install MSYS2.MSYS2
</code></pre>
<h3 id="install-msys2-with-chocolatey-for-windows-8">Install MSYS2 with Chocolatey (for Windows 8)</h3>
<p><a href="https://chocolatey.org/">Chocolatey</a> is a third-party command line package manager for Windows 8, Windows 10 and Windows 11, always run Chocolatey commands in a powershell/cmd with administrator rights (right click on <code>Start</code> menu, select <code>Windows Powershell (Admin)</code> or <code>Command Prompt (Admin)</code>):</p>
<ol>
<li>Open a powershell (admin) (not a cmd) and copy the official <a href="https://chocolatey.org/install">Chocolatey install command</a> to install Chocolatey</li>
<li>In a powershell/cmd (admin) execute the command:</li>
</ol>
<pre><code class="lang-cmd">choco install msys2 -y
</code></pre>
<p>As alternative write this text file <code>install_choco_msys2.cmd</code>, right click and select <code>Run as administrator</code>:</p>
<details><summary>Click to view</summary>
<pre><code class="lang-cmd">@echo off
::https://chocolatey.org/install
::https://chocolatey.org/courses/installation/installing?method=installing-chocolatey?quiz=true

::download and run install.ps1
&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;
::install msys2
choco install msys2 -y
</code></pre>
</details>
<h3 id="install-msys2-with-the-official-installer">Install MSYS2 with the official installer</h3>
<ol>
<li>Download and start the <a href="https://www.msys2.org/">one-click installer for MSYS2</a>. MSYS2 no longer support an installer for Windows 32-bit, the <a href="https://github.com/msys2/msys2-installer/releases/tag/2020-05-17">latest provided</a> is not able to install packages.</li>
<li>The installer runs a <code>MSYS2 MSYS</code> shell as a last step. Update the core packages by typing and executing <code>pacman -Syuu</code>. When finished, close the <code>MSYS2 MSYS</code> shell.</li>
</ol>
<p>With MSYS2 installed to <code>C:\msys64</code> your home directory will be <code>C:\msys64\home\&lt;your_username&gt;</code>. Note that within the MSYS2 shell, paths are written in Unix-like way:</p>
<ul>
<li>Windows path: <code>C:\msys64</code></li>
<li>Unix-like path: <code>/c/msys64</code></li>
<li>Windows path: <code>C:\msys64\home</code></li>
<li>Unix-like path: <code>/home</code> or <code>/c/msys64/home</code></li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>You can also use <code>ls</code> to list the files and folders in a directory, similar to how you would use <code>dir</code> in Windows.</p>
</div>
<h3 id="gcc">GCC</h3>
<p>This works with all the Windows versions.</p>
<ol>
<li>Using your favorite text editor, copy and paste the following bash script, calling it <code>makefish.sh</code>:</li>
</ol>
<details><summary>64-bit Windows</summary>
<pre><code class="lang-bash">#!/bin/bash
# makefish.sh

# install packages if not already installed
pacman -S --noconfirm --needed unzip make mingw-w64-x86_64-gcc

branch='master'
github_user='official-stockfish'

# download the Stockfish source code
wget -O ${branch}.zip https://github.com/${github_user}/Stockfish/archive/refs/heads/${branch}.zip
unzip -o ${branch}.zip
cd Stockfish-${branch}/src
file_nnue=$(grep 'define.*EvalFileDefaultName' evaluate.h | grep -Ewo 'nn-[a-z0-9]{12}.nnue')
ls *.nnue | grep -v ${file_nnue} | xargs -d '\n' -r rm --

# check all given flags
check_flags () {
    for flag; do
        printf '%s\n' &quot;$flags&quot; | grep -q -w &quot;$flag&quot; || return 1
    done
}

# find the CPU architecture
output=$(g++ -Q -march=native --help=target)
flags=$(printf '%s\n' &quot;$output&quot; | awk '/\[enabled\]/ {print substr($1, 3)}' | tr '\n' ' ')
arch=$(printf '%s\n' &quot;$output&quot; | awk '/march/ {print $NF; exit}' | tr -d '[:space:]')

if check_flags 'avx512vnni' 'avx512dq' 'avx512f' 'avx512bw' 'avx512vl'; then
  arch_cpu='x86-64-vnni256'
elif check_flags 'avx512f' 'avx512bw'; then
  arch_cpu='x86-64-avx512'
elif check_flags 'bmi2' &amp;&amp; [ $arch != 'znver1' ] &amp;&amp; [ $arch != 'znver2' ]; then
  arch_cpu='x86-64-bmi2'
elif check_flags 'avx2'; then
  arch_cpu='x86-64-avx2'
elif check_flags 'sse4.1' 'popcnt'; then
  arch_cpu='x86-64-sse41-popcnt'
elif check_flags 'ssse3'; then
  arch_cpu='x86-64-ssse3'
elif check_flags 'sse3' 'popcnt'; then
  arch_cpu='x86-64-sse3-popcnt'
else
  arch_cpu='x86-64'
fi

# build the fastest Stockfish executable
make -j profile-build ARCH=${arch_cpu} COMP=mingw
make strip
mv stockfish.exe ../../stockfish_${arch_cpu}.exe
make clean
cd
</code></pre>
</details>
<details><summary>32-bit Windows</summary>
<pre><code class="lang-bash">#!/bin/bash
# makefish.sh

# install packages if not already installed
pacman -S --noconfirm --needed unzip make mingw-w64-i686-gcc

branch='master'
github_user='official-stockfish'

# download the Stockfish source code
wget -O ${branch}.zip https://github.com/${github_user}/Stockfish/archive/refs/heads/${branch}.zip
unzip -o ${branch}.zip
cd Stockfish-${branch}/src
file_nnue=$(grep 'define.*EvalFileDefaultName' evaluate.h | grep -Ewo 'nn-[a-z0-9]{12}.nnue')
ls *.nnue | grep -v ${file_nnue} | xargs -d '\n' -r rm --

# find the CPU architecture
gcc_enabled=$(g++ -Q -march=native --help=target | grep &quot;\[enabled\]&quot;)
gcc_arch=$(g++ -Q -march=native --help=target | grep &quot;march&quot;)

if [[ &quot;${gcc_enabled}&quot; =~ &quot;-mpopcnt &quot; &amp;&amp; &quot;${gcc_enabled}&quot; =~ &quot;-msse4.1 &quot; ]] ; then
  arch_cpu=&quot;x86-32-sse41-popcnt&quot;
elif [[ &quot;${gcc_enabled}&quot; =~ &quot;--msse2 &quot; ]] ; then
  arch_cpu=&quot;x86-32-sse2&quot;
else
  arch_cpu=&quot;x86-32&quot;
fi

# build the fastest Stockfish executable
make -j profile-build ARCH=${arch_cpu} COMP=mingw
make strip
mv stockfish.exe ../../stockfish_${arch_cpu}.exe
make clean
cd
</code></pre>
</details>
<ol start="2">
<li>Start a <code>MSYS2 MinGW x64</code> shell (not a <code>MSYS2 MSYS</code> one), <code>C:\msys64\mingw64.exe</code>, or start a <code>MSYS2 MinGW x86</code> shell, <code>C:\msys64\mingw32.exe</code>, to build a 32 bit application.</li>
<li>Navigate to wherever you saved the script (e.g. type and execute <code>cd '/d/Program Files/Stockfish'</code> to navigate to <code>D:\Program Files\Stockfish</code>).</li>
<li>Run the script by typing and executing <code>bash makefish.sh</code>.</li>
</ol>
<h3 id="clangllvm">Clang/LLVM</h3>
<p>With Windows version older than Windows 10 you could need to install the Microsoft Windows Universal C Runtime.</p>
<ol>
<li>Using your favorite text editor, copy and paste the following bash script, calling it <code>makefish.sh</code>:</li>
</ol>
<details><summary>64-bit Windows</summary>
<pre><code class="lang-bash">#!/bin/bash
# makefish.sh

# install packages if not already installed
pacman -S --noconfirm --needed unzip make mingw-w64-clang-x86_64-clang

branch='master'
github_user='official-stockfish'

# download the Stockfish source code
wget -O ${branch}.zip https://github.com/${github_user}/Stockfish/archive/refs/heads/${branch}.zip
unzip -o ${branch}.zip
cd Stockfish-${branch}/src
file_nnue=$(grep 'define.*EvalFileDefaultName' evaluate.h | grep -Ewo 'nn-[a-z0-9]{12}.nnue')
ls *.nnue | grep -v ${file_nnue} | xargs -d '\n' -r rm --

# check all given flags
check_flags () {
    for flag; do
        printf '%s\n' &quot;$flags&quot; | grep -q -w &quot;$flag&quot; || return 1
    done
}

# find the CPU architecture
output=$(clang++ -E - -march=native -### 2&gt;&amp;1)
flags=$(printf '%s\n' &quot;$output&quot; | grep -o '&quot;-target-feature&quot; &quot;[^&quot;]*&quot;' | cut -d '&quot;' -f 4 | grep '^\+' | cut -c 2- | tr '\n' ' ')
arch=$(printf '%s\n' &quot;$output&quot; | grep -o '&quot;-target-cpu&quot; &quot;[^&quot;]*&quot;' | cut -d '&quot;' -f 4)

if check_flags 'avx512vnni' 'avx512dq' 'avx512f' 'avx512bw' 'avx512vl'; then
  arch_cpu='x86-64-vnni256'
elif check_flags 'avx512f' 'avx512bw'; then
  arch_cpu='x86-64-avx512'
elif check_flags 'bmi2' &amp;&amp; [ $arch != 'znver1' ] &amp;&amp; [ $arch != 'znver2' ]; then
  arch_cpu='x86-64-bmi2'
elif check_flags 'avx2'; then
  arch_cpu='x86-64-avx2'
elif check_flags 'sse4.1' 'popcnt'; then
  arch_cpu='x86-64-sse41-popcnt'
elif check_flags 'ssse3'; then
  arch_cpu='x86-64-ssse3'
elif check_flags 'sse3' 'popcnt'; then
  arch_cpu='x86-64-sse3-popcnt'
else
  arch_cpu='x86-64'
fi

# build the fastest Stockfish executable
make -j profile-build ARCH=${arch_cpu} COMP=clang
make strip COMP=clang
mv stockfish.exe ../../stockfish_${arch_cpu}.exe
make clean COMP=clang
cd
</code></pre>
</details>
<ol start="2">
<li>Start a <code>MSYS2 MinGW Clang x64</code> shell, <code>C:\msys64\clang64.exe</code>.</li>
<li>Navigate to wherever you saved the script (e.g. type and execute <code>cd '/d/Program Files/Stockfish'</code> to navigate to <code>D:\Program Files\Stockfish</code>).</li>
<li>Run the script by typing and executing <code>bash makefish.sh</code>.</li>
</ol>
<h3 id="microsoft-visual-studio">Microsoft Visual Studio</h3>
<div class="CAUTION">
<h5>Caution</h5>
<p>Building Stockfish with Visual Studio is <strong>not officially supported</strong>.</p>
</div>
<p>It is required to explicitly set the stack reserve to avoid crashes. See point 5. below.</p>
<p>If you want to use MSVC to get a &quot;optimized&quot; build, you can change these settings in the IDE:</p>
<ol>
<li>Add &quot;NDEBUG;USE_POPCNT;USE_PEXT&quot; to preprocessor definitions. Optionally, depending on your processor's support, add one of the following definitions: USE_AVX512 / USE_AVX2 / USE_SSSE3 / USE_SSE2 / USE_MMX. Also, if your processor supports VNNI instructions, add the USE_AVXVNNI definition. For a 64-bit target, if your CPU supports AVX or later extensions set one of the following: /arch:AVX or /arch:AVX2 or /arch:AVX512.</li>
<li>Optimization flags: /O2, /Oi, /Ot, /Oy, /GL</li>
<li>Static link with runtime: /MT.</li>
<li>Disable stack cookies: /GS-.</li>
<li>Set stack reserve to 8388608 in under Linker -&gt; System or use the linker option /STACK:reserve=8388608.</li>
<li>Disable debugging information in compiler/linker.</li>
<li>(VS 2017 only): Make a PGO instrument build(set under General), it should depend on &quot;pgort140.dll&quot; and it probably won't start.</li>
<li>(VS 2017 only): Copy pgort140.dll from &quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\Hostx64\x64&quot; to the output folder.</li>
<li>Run bench with the instrument build(very slow) and quit, it should generate &quot;Stockfish.pgd&quot; and &quot;Stockfish!1.pgc&quot;.</li>
<li>Make a PGO optimized build(set under General), should show something like:</li>
</ol>
<pre><code>1&gt;0 of 0 ( 0.0%) original invalid call sites were matched.
1&gt;0 new call sites were added.
1&gt;54 of 4076 (  1.32%) profiled functions will be compiled for speed, and the rest of the functions will be compiled for size
1&gt;18615 of 46620 inline instances were from dead/cold paths
1&gt;4076 of 4076 functions (100.0%) were optimized using profile data
1&gt;14499840744 of 14499840744 instructions (100.0%) were optimized using profile data
</code></pre>
<ol start="11">
<li>Enjoy, local tests show comparable speed to GCC builds.</li>
</ol>
<h3 id="troubleshooting">Troubleshooting</h3>
<p>If this tutorial will not work on your pc, you may try to change the <code>Windows Security</code> settings in via <code>Windows Security</code> &gt;&gt; <code>App &amp; Browser Control</code> &gt;&gt; <code>Exploit Protection Settings</code>:</p>
<ol>
<li>Try to turn off <em>&quot;Force randomization for images (Mandatory ASLR)&quot;</em>, if this not solve the problem then,</li>
<li>Try to turn off also <em>&quot;Randomize memory allocations (Bottom-up ASLR)&quot;</em> .</li>
</ol>
<h3 id="using-other-mingw-w64-with-msys2">Using other MinGW-w64 with MSYS2</h3>
<p>To use with MSYS2 a MinGW-w64 built by other projects, simply follow these instructions (Windows 64 bit):</p>
<ol>
<li><p>Download another version of MinGW-w64, e.g. <a href="https://www.msys2.org/">MinGW-w64 (64-bit) GCC 8.1.0</a>, extract the <em>mingw64</em> folder renaming it to <em>mingw64-810</em>, copy the folder into <em>C:\msys64</em>, check to have the directory <em>C:\msys64\mingw64-810\bin</em></p>
</li>
<li><p>Build Stockfish writing and executing this bash script</p>
</li>
</ol>
<details><summary>Click to view</summary>
<pre><code class="lang-bash">#!/bin/bash
# makefish.sh

# set PATH to use GCC 8.1.0
if [ -d &quot;/mingw64-810/bin&quot; ] ; then
  PATH=&quot;/mingw64-810/bin:${PATH}&quot;
else
  echo &quot;folder error&quot;
  exit 1
fi

branch='master'
github_user='official-stockfish'

# download the Stockfish source code
wget -O ${branch}.zip https://github.com/${github_user}/Stockfish/archive/refs/heads/${branch}.zip
unzip ${branch}.zip
cd Stockfish-${branch}/src

# find the CPU architecture
# CPU without popcnt and bmi2 instructions (e.g. older than Intel Sandy Bridge)
arch_cpu=x86-64
# CPU with bmi2 instruction (e.g. Intel Haswell or newer)
if [ &quot;$(g++ -Q -march=native --help=target | grep mbmi2 | grep enabled)&quot; ] ; then
  # CPU AMD zen
  if [ &quot;$(g++ -Q -march=native --help=target | grep march | grep 'znver[12]')&quot; ] ; then
    arch_cpu=x86-64-avx2
  else
    arch_cpu=x86-64-bmi2
  fi
# CPU with popcnt instruction (e.g. Intel Sandy Bridge)
elif [ &quot;$(g++ -Q -march=native --help=target | grep mpopcnt | grep enabled)&quot; ] ; then
  arch_cpu=x86-64-sse41-popcnt
fi

# build the Stockfish executable
make profile-build ARCH=${arch_cpu} COMP=mingw
make strip
mv stockfish.exe ../../stockfish_${arch_cpu}.exe
make clean 
cd
</code></pre>
</details>
<p>To use the compiler in the CLI write and run the script <code>use_gcc810.sh</code> in the user home folder</p>
<pre><code class="lang-bash"># set PATH to use GCC 8.1.0
# use this command: source use_gcc810.sh
if [ -d &quot;/mingw64-810/bin&quot; ] ; then
  PATH=&quot;/mingw64-810/bin:${PATH}&quot;
else
  echo &quot;folder error&quot;
fi
</code></pre>
<hr>
<h2 id="macos">macOS</h2>
<p>On macOS 10.14 or higher, it is possible to use the Clang compiler provided by Apple
to compile Stockfish out of the box, and this is the method used by default
in our Makefile (the Makefile sets the macosx-version-min=10.14 flag to select
the right libc++ library for the Clang compiler with recent c++17 support).</p>
<p>But it is quite possible to compile and run Stockfish on older versions of macOS! Below
we describe a method to install a recent GNU compiler on these Macs, to get
the c++17 support. We have tested the following procedure to install gcc10 on
machines running macOS 10.7, macOS 10.9 and macOS 10.13.</p>
<ol>
<li><p>Install Xcode for your machine.</p>
</li>
<li><p>Install Apple command-line developer tools for Xcode, by typing the following
command in a Terminal:</p>
<pre><code class="lang-bash">sudo xcode-select --install
</code></pre>
</li>
<li><p>Go to the Stockfish &quot;src&quot; directory, then try a default build and run Stockfish:</p>
<pre><code class="lang-bash">make clean
make build
make net
./stockfish
</code></pre>
</li>
<li><p>If step 3 worked, congrats! You have a compiler recent enough on your Mac
to compile Stockfish. If not, continue with step 5 to install GNU gcc10 :-)</p>
</li>
<li><p>Install the MacPorts package manager (<a href="https://www.macports.org/install.php">https://www.macports.org/install.php</a>),
for instance using the fast method in the &quot;macOS Package (.pkg) Installer&quot;
section of the page.</p>
</li>
<li><p>Use the &quot;port&quot; command to install the gcc10 package of MacPorts by typing the
following command:</p>
<pre><code class="lang-bash">sudo port install gcc10
</code></pre>
</li>
</ol>
<p>With this step, MacPorts will install the gcc10 compiler under the name &quot;g++-mp-10&quot;
in the /opt/local/bin directory:</p>
<pre><code>which g++-mp-10

/opt/local/bin/g++-mp-10       &lt;--- answer
</code></pre>
<ol start="7">
<li><p>You can now go back to the &quot;src&quot; directory of Stockfish, and try to build
Stockfish by pointing at the right compiler:</p>
<pre><code class="lang-bash">make clean
make build COMP=gcc COMPCXX=/opt/local/bin/g++-mp-10
make net
./stockfish
</code></pre>
</li>
<li><p>Enjoy Stockfish on macOS!</p>
</li>
</ol>
<p>See <a href="https://github.com/official-stockfish/Stockfish/pull/3049">this pull request</a> for further discussion.</p>
<hr>
<h2 id="for-android">For Android</h2>
<p>You can build Stockfish for your ARM CPU based mobile Android device,
using the Stockfish supplied Makefile.</p>
<p>Supported architectures are:</p>
<ul>
<li><strong>armv7</strong>: 32 bit ARM CPUs without Neon extension</li>
<li><strong>armv7-neon</strong>: 32 bit ARM CPUs with Neon SIMD Instruction Set Extension</li>
<li><strong>armv8</strong>: 64 bit ARM CPUs, with Neon extension</li>
</ul>
<p>As most modern Android smartphones and tablets nowadays use armv8 64 bit CPUs,
we will cover these in this example. Before you try to build Stockfish, make sure
that you know what kind of CPU architecture your device uses. You will have to specify
one of the three mentioned architectures later on in the MAKE command by giving the
<code>&quot;ARCH=...&quot;</code> variable on the command line.</p>
<p>Furthermore you should be aware of the fact that Stockfish is just the chess engine.
You cannot use it stand-alone, rather you need a host program, i.e. a Chess GUI that
displays the chess board, takes your moves etc. on the one hand, and on the other hand
&quot;talks&quot; to the Stockfish chess engine so that it analyses the chess position in a game
and calculates its moves or variations, and gives that back to the GUI for display.</p>
<p>The Chess GUI which is probably used most often on Android is Droidfish, so we will
cover this here. You can get it from the <a href="https://f-droid.org/repository/browse/?fdid=org.petero.droidfish">F-Droid</a> alternative app store.</p>
<p>To build Stockfish, you need:</p>
<ol>
<li><p>The Android Native Development Kit (NDK), which contains a C/C++ compiler toolchain
and all required headers and libraries to build native software for Android.</p>
</li>
<li><p>POSIX compatible build enviroment with GNU <code>coreutils</code>, <code>fileutils</code>and the <code>make</code>, <code>git</code>,
<code>expect</code> (if you want to run the testsuite) and either <code>wget</code> or <code>curl</code> utilities.</p>
<p>On Linux, install those tools using the package manager of your Linux distribution.</p>
<p>On Windows, you can use MSYS2. We will assume further down in this example that
you installed it to &quot;C:\msys64&quot;. Adapt the instructions accordingly, if you installed
it elsewhere.</p>
<p>Please see <a href="#windows">how to compile on Windows</a>
for more details about MSYS2, but <em><strong>please note</strong></em> that you ONLY need to install the basic
MSYS environment and the package groups <code>base-devel</code>, <code>expect</code> and <code>git</code> with this command:</p>
<pre><code class="lang-bash">pacman -S --noconfirm --needed base-devel expect git wget curl
</code></pre>
<p>You do NOT need any of the MINGW64, MINGW32 nor the CLANG64 compiler toolchain for an Android build.
We will use the Android NDK compiler toolchain instead.</p>
</li>
</ol>
<p>To get the Android NDK, you have two options:</p>
<p>a) If you already have Android Studio installed, use its built-in SDK manager to download
and install the NDK, as follows:</p>
<ul>
<li><p>On the &quot;Welcome to Android Studio&quot; start page of the IDE, click &quot;Customize&quot; on the left pane,
then click &quot;All Settings...&quot; on the bottom. This should open the &quot;Android SDK&quot; maintenance dialog.</p>
</li>
<li><p>Click on the &quot;SDK Tools&quot; tab on top of the list window.</p>
</li>
<li><p>Click and select the &quot;NDK (Side by Side)&quot; option and then click on &quot;OK&quot;
This will download and install the latest NDK version under the directory
of the &quot;Android SDK Location&quot; directory.</p>
<p>In this example, for the Windows environment we will assume that Android Studio is installed
in &quot;C:\Android\Android Studio&quot;, and that the Android SDK is installed in &quot;C:\Android\Sdk&quot;.
The NDK will then have been installed in &quot;C:\Android\Sdk\ndk&quot; by the above installation process.</p>
</li>
</ul>
<p>b) If you do NOT have Android Studio installed, don't worry! You don't need it.
To download just the Android NDK, go to <a href="https://developer.android.com/ndk/downloads">https://developer.android.com/ndk/downloads</a>
and pick the latest version for your platform. In this example we will stick to either Windows
or Linux, but the Mac version should be not much different to use.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The latest LTS version is r23b (23.1.7779620). This will work fine. The minimum version you need is r21e (21.4.7075529), so if you already have that, you are all set.</p>
</div>
<p>If you downloaded it directly, unzip it to &quot;C:\Android\Sdk\ndk&quot;, or if you are on Linux, inside your home
directory to /home/(your user name)/Android/Sdk/ndk</p>
<p>When the installation is finished, locate the NDK compiler toolchain directory.</p>
<p>On Windows, this should be something like:
&quot;C:\Android\Sdk\ndk\23.1.7779620\toolchains\llvm\prebuilt\windows-x86_64&quot;</p>
<p>On Linux, the path might look like:
/home/johndoe/Android/Sdk/ndk/23.1.7779620/toolchains/llvm/prebuilt/linux-x86_64</p>
<p>On Linux, we are now almost ready to go. On Windows however, to simplify its use with MSYS2, we will
now create a symbolic link to that directory inside the MSYS2 installation directory.
To do that, open a CMD.EXE command prompt with Administrator privileges, and use the Windows command MKLINK as follows:</p>
<pre><code class="lang-cmd">mklink /D &quot;C:\msys64\Android&quot; &quot;C:\Android\Sdk\ndk\23.1.7779620\toolchains\llvm\prebuilt\windows-x86_64&quot;
</code></pre>
<p>Now the Android NDK compiler toolchain is available from inside an MSYS environment terminal session
in the same way as the MINGW64 toolchain would be, and we don't have to type such long path names anymore.</p>
<p>On Windows, you should now start the MSYS environment launcher. This will give you a terminal session
with the Bash (1) shell. The PATH environment variable DOES NOT include a compiler toolchain yet. Verify this by entering:</p>
<pre><code class="lang-bash">$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/opt/bin:/c/Windows/System32:/c/Windows:/c/Windows/System32/Wbem:/c/Windows/System32/WindowsPowerShell/v1.0/:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl
</code></pre>
<p>On Linux, you can just open a plain terminal session.</p>
<p>Now we prepend the NDK compiler toolchain bin/ subdirectory to our PATH:</p>
<p>On Windows:</p>
<pre><code class="lang-bash">$ export PATH=/Android/bin:$PATH
</code></pre>
<p>On Linux:</p>
<pre><code class="lang-bash">$ export PATH=/home/johndoe/Android/Sdk/ndk/23.1.7779620/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>These PATH settings are in effect only for your current session.</p>
</div>
<p>Now you should be able to call the compiler we will use from the command line.
Let's check which version we have, this example output is from Windows, the Linux output should be quite similar.</p>
<pre><code class="lang-bash">$ aarch64-linux-android21-clang++ --version
Android (7019983 based on r365631c3) clang version 9.0.9 (https://android.googlesource.com/toolchain/llvm-project a2a1e703c0edb03ba29944e529ccbf457742737b) (based on LLVM 9.0.9svn)
Target: aarch64-unknown-linux-android21
Thread model: posix
InstalledDir: C:\msys64\Android\bin
$
</code></pre>
<p>If you get an error message that the command &quot;aarch64-linux-android21-clang++&quot; could not be found, please go back
and check that you have got all the path names correct in the above steps.</p>
<p>Now we will checkout the Stockfish source code with git, and start the build. The steps for Windows in the MSYS environment
session and for Linux are now basically the same. In your home directory, make subdirectories for the git checkout:</p>
<pre><code class="lang-bash">$ mkdir -p ~/repos/official-stockfish
$ cd ~/repos/official-stockfish
$ git clone https://github.com/official-stockfish/Stockfish.git
.
.
.
$ cd Stockfish/src
</code></pre>
<p>Now lets start the build. First we can display a help page with all the supported make targets (and ignore them :-)</p>
<pre><code class="lang-bash">$ make help
</code></pre>
<p>Next we download the NNUE neural network that powers Stockfish's evaluation. By default, it will be embedded into the
compiled <code>stockfish</code> executable.</p>
<pre><code class="lang-bash">$ make net
</code></pre>
<p>This should download <code>&lt;some hex hash code...&gt;.nnue</code> file. If you get an error message that neither <code>curl</code>
nor <code>wget</code> are installed, then please install one of these tools and repeat.</p>
<p>Now we are ready to build. You now need to know your architecture (see the start of this documentation).
We will use armv8 as an example here. Issue the command:</p>
<pre><code class="lang-bash">$ make -j build ARCH=armv8 COMP=ndk
</code></pre>
<p>After a short amount of time (or a minute, or two, depending on the speed of your machine) the compilation and
linking should complete with messages like this:</p>
<pre><code class="lang-bash">.
.
aarch64-linux-android21-clang++ -o stockfish benchmark.o bitbase.o bitboard.o endgame.o evaluate.o main.o material.o misc.o movegen.o movepick.o pawns.o position.o psqt.o search.o thread.o timeman.o tt.o uci.o ucioption.o tune.o tbprobe.o evaluate_nnue.o half_ka_v2_hm.o  -static-libstdc++ -pie -lm -latomic -Wall -Wcast-qual -fno-exceptions -std=c++17  -stdlib=libc++ -fPIE -DUSE_PTHREADS -DNDEBUG -O3 -fexperimental-new-pass-manager -DIS_64BIT -DUSE_POPCNT -DUSE_NEON=8 -flto
make[1]: Leaving directory '/home/johndoe/repos/official-stockfish/Stockfish/src'
</code></pre>
<p>You will now have a binary file called <code>stockfish</code> in your current directory. Check with the file command that
it is indeed an ARM binary for Android:</p>
<pre><code class="lang-bash">$ file stockfish
stockfish: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, with debug_info, not stripped
</code></pre>
<p>To make it smaller and run faster, we should strip the symbol table from the executable; this is not needed for running it, only for debugging.
Issue the command:</p>
<pre><code class="lang-bash">$ make strip ARCH=armv8 COMP=ndk
aarch64-linux-android-strip stockfish
</code></pre>
<p>Issuing the file command again shows that it has been stripped:</p>
<pre><code class="lang-bash">$ file stockfish
stockfish: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, stripped
</code></pre>
<p>It is a good idea to rename the binary:</p>
<pre><code class="lang-bash">$ mv stockfish stockfish_DEV_armv8
</code></pre>
<p>So in Droidfish you will be able to see that you are running your self compiled DEVelopment version of Stockfish, and not the built-in
version, which is substantially older.</p>
<p>Voilà: you have your Android build of Stockfish. What is now left to do is to copy it over to your smartphone or tablet,
to the &quot;uci&quot; subdirectory of your Droidfish installation. You can find the Droidfish documentation here:
<a href="https://github.com/peterosterlund2/droidfish/tree/master/doc">https://github.com/peterosterlund2/droidfish/tree/master/doc</a></p>
<p>To do this, the easiest possibility is to have your build machine and your Android device on the same network,
create a Windows network share, copy the Stockfish binary into that share directory, and then on your Android
device use the File Manager app to connect to that network share and copy the Stockfish binary over to the
Droidfish uci (engines) directory.</p>
<p>In Droidfish, open the left menu, find the Engines management submenu, pick the <code>stockfish_DEV_armv8</code> binary,
and in the configuration menu adjust its UCI parameter settings. Depending on the CPU power of your device
and the available memory, you should probably give it more than the default one Thread, and more than the default
16 MB of Hash memory. A good start would be to try 2 Threads, and 512 MB for the Hash tables, and see if you can beat it ;-)</p>
<div class="WARNING">
<h5>Warning</h5>
<p>As Stockfish is a very computation-intense program, you should probably not give it as many threads as your device CPU has processor cores. Especially in Analysis mode, when Stockfish is thinking permanently, and for extended amounts of time, this might suck your device battery empty quite quickly.</p>
</div>
<p>Enjoy!</p>
<hr>
<h2 id="cross-compilation">Cross compilation</h2>
<h3 id="for-windows-in-ubuntu">For Windows in Ubuntu</h3>
<p>The script works with Ubuntu 18.04, Ubuntu 21.10 and Ubuntu 22.04, other versions could still have a packaging bug.</p>
<details><summary>Click to view</summary>
<pre><code class="lang-bash">#!/bin/bash
# functions to build Stockfish
_build_sf () {
make build ARCH=x86-64$1 COMP=mingw -j
make strip COMP=mingw
mv stockfish.exe ../../stockfish-x64${1}.exe
make clean COMP=mingw
}

_build_sf_pgo () {
make profile-build ARCH=x86-64$1 COMP=mingw PGOBENCH=&quot;wine ./stockfish.exe bench&quot; -j
make strip COMP=mingw
mv stockfish.exe ../../stockfish-x64${1}-pgo.exe
make clean COMP=mingw
}

# full-upgrade and install required packages
sudo apt update &amp;&amp; sudo apt full-upgrade -y &amp;&amp; sudo apt autoremove -y &amp;&amp; sudo apt clean
sudo apt install -y \
  make \
  mingw-w64 \
  git \
  wine64 \
  binutils

# clone Stockfish source code
git clone --single-branch --branch master https://github.com/official-stockfish/Stockfish.git
cd Stockfish/src

# build Stockfish executables
# to speedup the building process you can keep only the section fitting your CPU architecture

# build the binary for CPUs without popcnt and bmi2 instructions (e.g. older than Intel Sandy Bridge)
_build_sf_pgo
  
# build the binary for CPU with popcnt instruction (e.g. Intel Sandy Bridge)
if [ &quot;$(x86_64-w64-mingw32-c++-posix -Q -march=native --help=target | grep mpopcnt | grep enabled)&quot; ] ; then
  _build_sf_pgo -sse41-popcnt
else
  _build_sf -sse41-popcnt
fi
  
# build the binary for CPU with bmi2 instruction (e.g. Intel Haswell or newer)
if [ &quot;$(x86_64-w64-mingw32-c++-posix -Q -march=native --help=target | grep mbmi2 | grep enabled)&quot; ] ; then
  _build_sf_pgo -bmi2
else
  _build_sf -bmi2
fi
</code></pre>
</details>
<h3 id="for-all-platforms-hosttarget-using-zig">For all platforms (host/target) using Zig</h3>
<p><a href="https://ziglang.org/">Zig</a> is a programming language in early development stage that is binary compatible with C.
The Zig toolchain, based on LLVM, ships the source code of all the required libraries to easily cross compile Zig/C/C++ code for several CPU Architecture and OS combinations. All the work required is to set as target the proper supported <a href="https://github.com/ziglang/zig-bootstrap#supported-triples">triple &lt;arch-os-abi&gt;</a> (eg <code>x86_64-windows-gnu</code>, <code>aarch64-linux-musl</code>).</p>
<p>You can use Zig:</p>
<ul>
<li>installing Zig with a <a href="https://github.com/ziglang/zig/wiki/Install-Zig-from-a-Package-Manager">package manager</a> for your OS, or</li>
<li>unzipping the <a href="https://ziglang.org/download/">Zig archive</a> (~70 Mbi) and setting the PATH for the shell with <code>export PATH=/home/username/zig:$PATH</code></li>
</ul>
<p>Here is a script to cross compile from a clean Ubuntu a static build of Stockfish targeting an armv8 or armv7 CPU running on Linux or Android:</p>
<details><summary>Click to view</summary>
<pre><code class="lang-bash"># Use a clean Ubuntu to cross compile
# a static build for armv8 and armv7 on Linux/Android

# one time configuration
sudo apt update &amp;&amp; sudo apt install -y make git
sudo snap install zig --classic --edge
sudo apt install -y qemu-user

# armv8 static build with musl libc
git clone https://github.com/official-stockfish/Stockfish.git
cd Stockfish/src
make -j build ARCH=armv8 COMP=clang CXX=&quot;zig c++ -target aarch64-linux-musl&quot;

# test: qemu's magic at work
qemu-aarch64 stockfish compiler
qemu-aarch64 stockfish bench

# armv7 static build with musl libc
make clean
make -j build ARCH=armv7 COMP=clang CXX=&quot;zig c++ -target arm-linux-musleabihf&quot;

# test: qemu's magic at work
qemu-arm stockfish compiler
qemu-arm stockfish bench

</code></pre>
</details>
<p>Here is a script to cross compile from a msys2 msys/mingw-w64 shell a static build of Stockfish targeting an armv8 or armv7 CPU running on Linux or Android:</p>
<details><summary>Click to view</summary>
<pre><code class="lang-bash"># Use msys2 to cross compile
# a static build for armv8 and armv7 on Linux/Android

# one time configuration
pacman -S --noconfirm --needed git make unzip
wget https://ziglang.org/builds/zig-windows-x86_64-0.14.0-dev.2546+0ff0bdb4a.zip

unzip zig-windows-x86_64-0.14.0-dev.2546+0ff0bdb4a.zip
export PATH=&quot;$(pwd)/zig-windows-x86_64-0.14.0-dev.2546+0ff0bdb4a:$PATH&quot;

# armv8 static build with musl libc
git clone https://github.com/official-stockfish/Stockfish.git
cd Stockfish/src
make -j build ARCH=armv8 COMP=clang CXX=&quot;zig c++ -target aarch64-linux-musl&quot;
mv stockfish.exe stockfish_armv8
</code></pre>
</details>
<hr>
<h2 id="lower-compilation-time">Lower compilation time</h2>
<p>It is possible to lower the compile time on cpu multi core using make with the flag <em>-j &lt;n_jobs&gt;</em>, where &lt;n_jobs&gt; is the number of jobs (commands) to run simultaneously. The flag <em>-j</em> enables one job for each logical CPU core.</p>
<pre><code class="lang-bash">make -j &lt;n_jobs&gt; profile-build ARCH=x86-64-avx2 COMP=mingw
</code></pre>
<hr>
<h2 id="optimize-for-your-cpu">Optimize for your CPU</h2>
<p>To get the max speedup for your CPU (1.5% on Ivy Bridge) simply prepend the shell variable <code>CXXFLAGS='-march=native'</code> to the <code>make</code> command. At example, for a CPU Sandy/Ivy Bridge use this command:</p>
<pre><code class="lang-bash">CXXFLAGS='-march=native' make -j profile-build ARCH=x86-64-avx2 COMP=gcc
</code></pre>
<p>To view the compiler flags for your CPU:</p>
<pre><code># for gcc
gcc -Q -march=native --help=target | grep -v &quot;\[disabled\]&quot;

# for clang
clang -E - -march=native -###
</code></pre>
<p><em>-march=native</em> implies <em>-mtune=native</em>, below a high level explanation of the compiler flags <em>-march</em> and <em>-mtune</em>, view the <a href="https://gcc.gnu.org/onlinedocs/gcc-5.3.0/gcc/x86-Options.html#x86-Options">gcc manual</a> for more technically sound details:</p>
<ul>
<li><p><em>-march</em>: determines what instruction sets are used in the binary. An instruction set is the list of commands implemented by the cpu. <strong>The generated code may not run at all on processors other than the one indicated.</strong></p>
</li>
<li><p><em>-mtune</em>: determines the cost model that is used when generating code. The cost model describes how long it takes the cpu to do operations. This information is used by the scheduler to decide what operations to use and in what order.</p>
</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Moosdorf/Chess-Website-FULLSTACK/blob/main/Server/Stockfish/wiki/Compiling-from-source.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
